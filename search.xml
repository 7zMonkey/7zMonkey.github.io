<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>目录</title>
      <link href="/blog/f4961fb375b4.html"/>
      <url>/blog/f4961fb375b4.html</url>
      
        <content type="html"><![CDATA[<ol><li><a href="https://www.7zmonkey.tech/blog/233601af6e0a.html">序</a></li><li><a href="">目录</a></li><li><a href="https://www.7zmonkey.tech/blog/79b9f490ba99.html">单例模式 - 使用闭包完成单例模式开发</a></li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序</title>
      <link href="/blog/233601af6e0a.html"/>
      <url>/blog/233601af6e0a.html</url>
      
        <content type="html"><![CDATA[<p>设计模式通常是一种编程思想，常见的设计模式是对常见开发模式的总结归纳。它如同算法并不局限于某一种单一的编程语言，只要你对它理解透彻，那你在任何语言中都可以随心所欲的使用。</p><p>1995 年，GoF（Gang of Four，四人组&#x2F;四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。</p><p>「GoF设计模式」中将设计模式分成了三种创建型模式、结构型模式、行为型模式。</p><p><strong>创建型模式，主要描述如何创建一个模型的模式</strong>，例如工厂模式，单例模式等等。</p><p><strong>结构型模式，主要描述类和对象按照不同的模式组建成更大的结构</strong>，例如代理，桥接等等。</p><p><strong>行为型模型，主要描述类和对象之间的共同协作互助完成单一对象无法完成的任务</strong>，例如观察者，迭代器等等。</p><p>一个合格的程序员应该熟练掌握二十三种设计模式，在你看到某个功能的时候应该不由自主的想到应该使用什么样的设计模式，当然如果现在你还不能很好的理解所有的设计模式，不要慌张，从现在开始了解它，熟悉它就可以，每个人都是从不了解到熟悉的。</p><p>这个专栏将会带你入门设计模式，并且尽可能让你掌握二十三种设计模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式 - 使用闭包完成单例模式开发</title>
      <link href="/blog/759f0059ff34.html"/>
      <url>/blog/759f0059ff34.html</url>
      
        <content type="html"><![CDATA[<p>单例模式，也就是要确保在某一个类在全剧中只有一个实例，并且提供一个全局的访问点来访问这一实例。</p><p>如何实现一个单例模式，主要讲究两个字，一个字“存”，在类内存在一个属性，如果这个属性不为空那么就初始化当前类赋值给这一属性，另一个字“堵”，将所有的可能再次实例化当前类的方法都“堵”住，并且返回“存”的实例，当然在第一个次实例的时候需要正常实例化，也就是存放实例的属性为空时，可以正常实例化。</p><p>在前端开发中可以使用闭包实现单例模式（当然也可以使用 Class 语法糖或者构造函数形式实现），我们将设想一个案例：将一些配置内容或者一些其他内容放在一个单例中供其他内容访问。</p><p>首先我们将通过闭包实现一个配置信息的管理，首先我们写一个简单的闭包代码，使 <code>config</code> 属性不受外部污染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createConfig = (() &#123;</span><br><span class="line"><span class="keyword">let</span> config;</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>但是我们要实现一个单例模式，就要在再次返回<code>config</code>前做判断，如果没有 <code>config</code> 要对他进行“实例化“并返回，如果存在 <code>config</code> 就将cunfig返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createConfig = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> config;</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!config) &#123;</span><br><span class="line">config = &#123; <span class="comment">/* 创建单例对象的代码 */</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="title function_">createConfig</span>(); <span class="comment">// 初始化实例</span></span><br></pre></td></tr></table></figure><p>当然这就完成了一个简单的配置对象的单例，但是我们发现现在的 <code>createConfig</code> 和直接返回一个对象没有什么区别，这是为什么？</p><p>有了配置对象的单例，不对对象进行操作基本上没什么用，属于”为醋包饺“，不提倡。</p><p>接下来我们将要实现的是，为配置对象新增 <code>set</code> 方法，这个方法将传入两个参数，分别是 <code>key</code> 和 <code>value</code>，作用就是将对象中的 <code>key</code> 的值改成 <code>value</code> 传入的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createConfig = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> instance;</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 如果不存在 instance 就初始化实例 否则返回原有的 instance</span></span><br><span class="line"><span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">instance = &#123;</span><br><span class="line"><span class="attr">config</span>: &#123;&#125;,</span><br><span class="line">set ( key, value ) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">config</span>[key] = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化两次 config 并且打印</span></span><br><span class="line"><span class="keyword">const</span> config1 = <span class="title function_">createConfig</span>();</span><br><span class="line"><span class="keyword">const</span> config2 = <span class="title function_">createConfig</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line"><span class="string">&#x27;config1:&#x27;</span>, config1.<span class="property">config</span>,</span><br><span class="line"><span class="string">&#x27;config2:&#x27;</span>, config2.<span class="property">config</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 config 观察 config2 信息</span></span><br><span class="line">config1.<span class="title function_">set</span>(<span class="string">&#x27;key&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;config2.config&#x27;</span>, config2.<span class="property">config</span>);</span><br></pre></td></tr></table></figure><p>当然在前端中不可能是一个页面打开一直不关闭，所以我们就要对数据进行缓存，一下案例中使用了 <code>localStorage</code> 和 <code>JSON</code> 对数据进行了处理，只能处理简单数据。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createConfig = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> instance;</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 如果不存在 instance 就初始化</span></span><br><span class="line"><span class="keyword">if</span> (!instance) &#123;</span><br><span class="line"><span class="comment">// 获取 localStorage 信息</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;config&#x27;</span>) ?? <span class="string">&#x27;&#123;&#125;&#x27;</span>)</span><br><span class="line">instance = &#123;</span><br><span class="line">config,</span><br><span class="line">set ( key, value ) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">config</span>[key] = value;</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;config&#x27;</span>, </span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>.<span class="property">config</span> ?? &#123;&#125;)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化两次并打印</span></span><br><span class="line"><span class="keyword">const</span> config1 = <span class="title function_">createConfig</span>();</span><br><span class="line"><span class="keyword">const</span> config2 = <span class="title function_">createConfig</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line"><span class="string">&#x27;config1:&#x27;</span>, config1.<span class="property">config</span>,</span><br><span class="line"><span class="string">&#x27;config2:&#x27;</span>, config2.<span class="property">config</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 config 观察 config2 信息</span></span><br><span class="line">config1.<span class="title function_">set</span>(<span class="string">&#x27;key&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;config2.config&#x27;</span>, config2.<span class="property">config</span>);</span><br></pre></td></tr></table></figure><blockquote><p>todo 使用 ES6 class形式 完成单例模式<br>todo 使用 构造函数形式 完成单例模式</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 JavaScript 中 Object 顺序的一些探索</title>
      <link href="/blog/f4a8e220f18b.html"/>
      <url>/blog/f4a8e220f18b.html</url>
      
        <content type="html"><![CDATA[<p>昨天的面试中出现了一个题目：</p><blockquote><p>将 对象 <code>&#123;6: 46, 8: 23, 14: 5, 10: 3&#125;</code> 按照值的顺序排列。</p></blockquote><p>由于做开始他说的一个数组，说这个题的时候我以为是类数组对象，结果是是如上的对象，排序嘛，（不考虑时间复杂度和空间复杂度的话）基本上没什么难度， 但是一直有一个疑惑在脑中，Object 不是无序的吗？</p><blockquote><p>本文主要探讨不同的 <em>Object</em> 定义方式（或者说声明方式）是否影响”<em>Object</em> 顺序“，”<em>Object</em> 顺序“是什么样的，以及常见处理”Object顺序“的方式。</p></blockquote><p>首先再次之前我的认为是”对象是无序的，数组是有序的，如果处理对象的顺序的话，还是使用数组对象<code>[&#123;key, value&#125;]</code>的方式“ 。</p><p>在 <a href="https://www.ecma-international.org/wp-content/uploads/ECMA-262_3rd_edition_december_1999.pdf">ECMA-262_3rd_edition_december_1999</a> 中有提到：</p><blockquote><p>4.3.3 Object<br>An <strong>object</strong> is a member of the type <strong>Object</strong>. It is an unordered collection of properties each of which contains a primitive value, object, or function. A function stored in a property of an object is called a method.</p></blockquote><p>也就是在 ES3 中是 Objiect 是乱序的，但是在 ES6 中逐渐开始在 Object 的中开始添加 Object 部分放的顺序之说。</p><p>不同浏览器在处理 <code>for...in</code> 时的解析顺序时不同的，在 Chrome 和 Opera 中遵循的是 <strong>ECMA-262</strong> 第五版本规范，而在 Firefox 和 Safari遵循的是 <strong>ECMA-262</strong>  第三版本规范。</p><p>在通常情况下，如果要处理对象的排序，我建议使用数组处理，也就是将对象处理为 <code>[&#123; key, value &#125;]</code> 这样的的数组形式，按照数组排序，因为我还是觉得对象是无序的，尽管他是按照一定的顺序排序的，但为了避免在不同的浏览器中的排序不同还是将他作为数组处理比较好。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://jartto.wang/2016/10/25/does-js-guarantee-object-property-order/">js能够保证object属性的输出顺序吗？ - Jartto’s blog</a></li><li><a href="https://stackoverflow.com/questions/5525795/does-javascript-guarantee-object-property-order">Does JavaScript guarantee object property order? - Stack Overflow</a></li><li><a href="https://www.ecma-international.org/wp-content/uploads/ECMA-262_3rd_edition_december_1999.pdf">ECMA-262_3rd_edition_december_1999</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Obsidian + Hexo + Github Pages + Github Actions 自动化部署博客</title>
      <link href="/blog/a871698f1912.html"/>
      <url>/blog/a871698f1912.html</url>
      
        <content type="html"><![CDATA[<p>当前网页使用 Obsidian 作为编辑器以及知识库，Hexo 作为静态博客框架，也、就是将markdown文档转换为静态 html ，放在 Github 并且部署 Github Pages 上的。</p><p>个人需需要将 Obsidian 的 markdown 文档放置在一个私有仓库，将 Hexo Template 放置在共有仓库，github pages 也放在另一个仓库，当然 Hexo Template 可以和 Github Pages 放在相同的仓库中，如果Hexo Template也需要分离的话在将其分离。</p><p>静态博客框架仓库和部署仓库分离的好处是如果更换静态博客框架例如Gatsby，VuePress的话，可以不需要修改部署仓库只需要新建新的静态博客框架仓库，调整Obsidian 仓库的 Actions 就可以。</p><p>分离的坏处就是需要有一个额外的仓库管理静态博客框架，当然个人觉得好处大于坏处。</p><p>在 Obsidian 仓库，和 Hexo 仓库分别设置了两个 Actions，Obsidian 的仓库 Actions 是主 Actions，Hexo 的 Actions 只是为了触发主 Actions。</p><p>也可以将主 Actions 放在 Hexo 上，甚至应该放到静态博客框架仓库里面，如果要更换静态博客框架，肯定需要重新修改主 Actions ，而且是大幅修改，而 Obsidian Actions 只需要修改触发的主 Actions 就可以，减少了不必要的 Obsidian 仓库的变动，如果没有仓库洁癖这些问题都是小问题。</p><p>本网站的部署 Actions 整体思路大致如下（ Local 代表本地仓库）：</p><pre class="mermaid">sequenceDiagramparticipant Local as Localparticipant Obsidian as Obsidianparticipant Hexo as Hexo Templateparticipant Github as Github Pagesopt 推送 Obsidian 触发    Local->>Obsidian:推送    Obsidian->>Obsidian: 触发endopt 推送 Hexo template 触发    Local->>Hexo: 推送    par Hexo Actions    Hexo->>Obsidian: 触发    endendpar Obsidian ActionsHexo->>Obsidian: 拉取Obsidian->>Obsidian:生成静态文件Obsidian->>Github:推送end</pre>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Github Actions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 CSS 选择器优先级的计算规则</title>
      <link href="/blog/61b7ac3ee9e9.html"/>
      <url>/blog/61b7ac3ee9e9.html</url>
      
        <content type="html"><![CDATA[<p>CSS优先级是一个值得思考的问题，再次之前我对CSS优先级的理解是:</p><blockquote><p>!important&gt;内联样式&gt;ID选择器&gt;类选择器&gt;类型选择器</p></blockquote><p>相信很多人对CSS优先级的理解也是这样的，但是一篇文章(<a href="http://c.biancheng.net/view/7216.html">CSS选择器的优先级（精讲版） (biancheng.net)</a>)上面书写了关于<strong>CSS 选择器优先级的计算规则</strong>的内容，使我开始对CSS优先级进行重新研究。</p><p>根据W3C给出关于选择器特异性(specificity，国内一般称优先级)的解释，选择器分为ABC三个等级，其中A为ID选择器，B包括类选择器、属性选择器和伪类，C包括类型选择器和伪元素，当然还存在一个通用选择器，但是通用选择器一般忽略。</p><table><thead><tr><th>等级</th><th>包含选择器</th></tr></thead><tbody><tr><td>A</td><td>计算选择器中 ID 选择器的数量</td></tr><tr><td>B</td><td>计算选择器中类选择器、属性选择器和伪类的数量</td></tr><tr><td>C</td><td>计算选择器中类型选择器和伪元素的数量</td></tr></tbody></table><p>优先级的计算，从A级开始到C级结束，如果到C级是两个选择器的优先级还是相等的那么有限选择靠后的选择器。</p><h3 id="重复简单选择器"><a href="#重复简单选择器" class="headerlink" title="重复简单选择器"></a>重复简单选择器</h3><p>CSS选择器允许重复出现简单选择器，并且简单选择器的重复出现会增加优先级。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span><span class="selector-class">.class</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.class</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说如上代码中第一个选择器重复出现了<code>.class</code>选择器，第二个选择器只出现了一个<code>.class</code>选择器，这两种写法都是正确的，并且第一个选择器<code>.class.class</code>的优先级大于第二个选择器<code>.class</code>，所以结果是背景颜色将呈现红色。</p><table><thead><tr><th>选择器</th><th>优先级 (A, B, C)</th></tr></thead><tbody><tr><td>.class.class</td><td>(0, 2, 0)</td></tr><tr><td>.class</td><td>(0, 1, 0)</td></tr></tbody></table><blockquote><p>在低版本CSS中可能简单重复选择器会被忽略，如在ie8中重复id或被忽略，在ie5中重复的class或被忽略。</p><p>拒绝IE，从我做起！</p></blockquote><h3 id="特殊选择器"><a href="#特殊选择器" class="headerlink" title="特殊选择器"></a>特殊选择器</h3><p>一些伪类和其他选择器中存在一些特殊的选择器，因此单独定义了这些特殊选择器的特异性。</p><ol><li>选择器<code>:is()</code>、<code>:not()</code>、<code>:has()</code>的优先级是选择器列表中最具有复杂性的选择器的优先级取代。</li><li>选择器<code>:nth-child()</code>、<code>:nth-last-child()</code>的优先级是伪类本身的优先级（计为一个伪类选择器，也就是计为B），再加上选择器列表中最具复杂性的选择器的优先级。</li><li>选择器<code>:where()</code>伪类的优先级被零代替，也就是没有优先级，再优先级计算中不做数。</li><li>通用选择符以及其他选择符在优先级中不计数。</li></ol><h3 id="优先级计算"><a href="#优先级计算" class="headerlink" title="优先级计算"></a>优先级计算</h3><table><thead><tr><th>选择器</th><th>优先级 (A, B, C)</th></tr></thead><tbody><tr><td>.class</td><td>(0, 1, 0)</td></tr><tr><td>#Red</td><td>(1, 0, 0)</td></tr><tr><td>.container :is(.container&gt;#Red, .container&gt;.class)</td><td>(1, 2, 0)</td></tr><tr><td>.container #Red.class:nth-child(1)</td><td>(1, 3, 0)</td></tr><tr><td>:is(.container&gt;.class.class)</td><td>(0, 3, 0)</td></tr><tr><td>#Red:is(.container&gt;.class)</td><td>(1, 2, 0)</td></tr><tr><td>.container div:nth-child(1)</td><td>(0, 2, 1)</td></tr><tr><td>:is(#Red.class)</td><td>(1, 1, 0)</td></tr><tr><td>#Red.class</td><td>(1, 1, 0)</td></tr><tr><td>#Red.class:nth-child(1)</td><td>(1, 2, 0)</td></tr><tr><td>#Red#Red</td><td>(2, 0, 0)</td></tr></tbody></table><p><a href="https://code.juejin.cn/pen/7103862825264611359">代码片段</a></p><p><a href="https://codepen.io/onemue/pen/RwQMBmd">codepen</a></p><h3 id="specificity求和"><a href="#specificity求和" class="headerlink" title="specificity求和"></a>specificity求和</h3><p>在一些其他文档中将讲A、B、C分别比作100,10,1 进行求和，是不准确的，如果按照这样做那么10个class是不是相当于一个id，显然不是。</p><p>在<a href="https://www.w3.org/TR/CSS1/#cascading-order">CSS Level 1</a>、<a href="https://drafts.csswg.org/selectors-3/#specificity">Selectors Level 3</a>中也有这样的描述。</p><p>在主流浏览器中高等级高于低等级是即使ABC求和相同也不会优先使用后声明的CSS。</p><p>造成这样的原因是<strong>权重的进制是并不是十进制，CSS 权重进制在 IE6 为 256，后来扩大到了 65536，现代浏览器则采用更大的数量</strong>。也可以理解<strong>选择器的权值不能进位</strong>，或者理解为选择器权值ABC单独计算比较。</p><h3 id="关于-important"><a href="#关于-important" class="headerlink" title="关于!important "></a>关于<code>!important </code></h3><p>MDN指出“使用 <code>!important</code> 是一个<strong>坏习惯</strong>，应该尽量避免”，并给出了使用<code>!important</code> 的情况：</p><ul><li><strong>一定</strong>要优先考虑使用样式规则的优先级来解决问题而不是 <code>!important</code></li><li><strong>只有</strong>在需要覆盖全站或外部 CSS 的特定页面中使用 <code>!important</code></li><li><strong>永远不要</strong>在你的插件中使用 <code>!important</code></li><li><strong>永远不要</strong>在全站范围的 CSS 代码中使用 <code>!important</code></li></ul><p>以及替代 <code>!important</code>的方法:</p><ol><li>更好地利用 CSS 级联属性</li><li>使用更具体的规则。在您选择的元素之前，增加一个或多个其他元素，使选择器变得更加具体，并获得更高的优先级。</li><li>对于（2）的一种特殊情况，当您无其他要指定的内容时，请复制简单的选择器以增加特异性。</li></ol><p>推荐阅读<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity#!important_%E4%BE%8B%E5%A4%96%E8%A7%84%E5%88%99">优先级 - CSS（层叠样式表） | MDN (mozilla.org)</a>，了解更多<code>!important</code>的使用意见。</p><h3 id="其他-CSS-优先规则"><a href="#其他-CSS-优先规则" class="headerlink" title="其他 CSS 优先规则"></a>其他 CSS 优先规则</h3><p><strong>CSS 优先规则1：</strong> 最近的祖先样式比其他祖先样式优先级高。</p><p><strong>CSS 优先规则2：</strong> “直接样式”比”祖先样式”优先级高。</p><p><strong>CSS 优先规则3：</strong> 优先级关系：内联样式 &gt; ID 选择器 &gt; 类选择器 &#x3D; 属性选择器 &#x3D; 伪类选择器 &gt; 标签选择器 &#x3D; 伪元素选择器。</p><p><strong>CSS 优先规则4：</strong> 计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照”就近原则”来判断。</p><p><strong>CSS 优先规则5：</strong> 属性后插有 <strong>!important</strong> 的属性拥有最高优先级。若同时插有 <strong>!important</strong>，则再利用规则 3、4 判断优先级。</p><blockquote><p>注意: 文档树中元素的接近度（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity#%E6%97%A0%E8%A7%86DOM%E6%A0%91%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB">Proximity of elements</a>）对优先级没有影响。</p></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://www.w3.org/TR/selectors/#specificity">Selectors Level 4</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity">优先级 - CSS（层叠样式表） | MDN (mozilla.org)</a></li><li><a href="https://www.runoob.com/w3cnote/css-style-priority.html">CSS 样式优先级 | 菜鸟教程 (runoob.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> WEB 标准 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
